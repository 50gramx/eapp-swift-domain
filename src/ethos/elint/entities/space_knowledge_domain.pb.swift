// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ethos/elint/entities/space_knowledge_domain.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Elint_Entity_SpaceKnowledgeDomainCollarEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The term "white-collar worker" was coined in the 1930s by Upton Sinclair, an American writer who referenced the word in connection to clerical, administrative and managerial functions during the 1930s.[2] A white-collar worker is a salaried professional, typically referring to general office workers and management.
  case whiteCollar // = 0

  /// A blue-collar worker is a member of the working class who performs manual labor and either earns an hourly wage or is paid piece rate for the amount of work done. This term was first used in 1924.[3]
  case blueCollar // = 1

  /// A pink-collar worker is also a member of the working class who performs in the service industry. They work in positions such as waiters, retail clerks, salespersons, and many other positions involving relations with people. The term was coined in the late 1970s as a phrase to describe jobs that were typically held by women; now the meaning has changed to encompass all service jobs.[4][5][6]
  case pinkCollar // = 2

  /// A gold-collar worker are high skilled multi-disciplinarian or knowledge worker who combines intellectual labor—which is typically white-collar—with the manual labor of blue-collar positions. Armed with highly specialized knowledge, gold-collar workers usually engage in problem-solving or complex technical work in fields such as academic/scientific research, engineering technicians and advanced technology industries.[7]
  case goldCollar // = 3

  /// Government workers of all types;[9] derived from compensation received from red ink budget. In China, it also refers to Communist Party officials in private companies.[10]
  case redCollar // = 4

  /// – Skilled workers, typically someone who is both white and blue collar; an example is information technology workers. They are principally white-collar, but perform blue-collar tasks with some regularity, such as engineers and technicians.
  case purpleCollar // = 5

  /// New collar – develops technical and soft skills needed to work in the contemporary technology industry through nontraditional education paths
  case newCollar // = 6

  /// No collar – Artists and "free spirits" who tend to privilege passion and personal growth over financial gain. This term was popularized on the reality game show Survivor: Worlds Apart, which used No Collar (in addition to White and Blue Collar) as the tribal divisions;[11] also, people who work, but not for payment.[9]
  case noCollar // = 7

  /// Orange collar – Prison laborers, named for the orange jumpsuits commonly worn by inmates.[9][12
  case orangeCollar // = 8

  /// Green collar – Workers in a wide range of professions relating to the environment and renewable energy.
  case greenCollar // = 9

  /// Scarlet collar – Workers in the sex industry[9]
  case scarletCollar // = 10

  /// Brown collar – Military personnel
  case brownCollar // = 11

  /// Steel collar - Robots, particularly in manufacturing that typically replace blue collar jobs.
  case steelCollar // = 12

  /// Black collar – Manual laborers in industries in which workers generally become very dirty, such as mining or oil-drilling;[9][13] has also been used to describe workers in illegal professions.
  case blackCollar // = 13

  /// Grey collar – workforce that is not classified in blue collar nor white collar. It is occasionally used to describe elderly individuals working beyond the age of retirement, as well as those occupations incorporating elements of both blue- and white-collar.
  case greyCollar // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .whiteCollar
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whiteCollar
    case 1: self = .blueCollar
    case 2: self = .pinkCollar
    case 3: self = .goldCollar
    case 4: self = .redCollar
    case 5: self = .purpleCollar
    case 6: self = .newCollar
    case 7: self = .noCollar
    case 8: self = .orangeCollar
    case 9: self = .greenCollar
    case 10: self = .scarletCollar
    case 11: self = .brownCollar
    case 12: self = .steelCollar
    case 13: self = .blackCollar
    case 14: self = .greyCollar
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whiteCollar: return 0
    case .blueCollar: return 1
    case .pinkCollar: return 2
    case .goldCollar: return 3
    case .redCollar: return 4
    case .purpleCollar: return 5
    case .newCollar: return 6
    case .noCollar: return 7
    case .orangeCollar: return 8
    case .greenCollar: return 9
    case .scarletCollar: return 10
    case .brownCollar: return 11
    case .steelCollar: return 12
    case .blackCollar: return 13
    case .greyCollar: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Elint_Entity_SpaceKnowledgeDomainCollarEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Elint_Entity_SpaceKnowledgeDomainCollarEnum] = [
    .whiteCollar,
    .blueCollar,
    .pinkCollar,
    .goldCollar,
    .redCollar,
    .purpleCollar,
    .newCollar,
    .noCollar,
    .orangeCollar,
    .greenCollar,
    .scarletCollar,
    .brownCollar,
    .steelCollar,
    .blackCollar,
    .greyCollar,
  ]
}

#endif  // swift(>=4.2)

struct Elint_Entity_SpaceKnowledgeDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spaceKnowledgeDomainID: String {
    get {return _storage._spaceKnowledgeDomainID}
    set {_uniqueStorage()._spaceKnowledgeDomainID = newValue}
  }

  var spaceKnowledgeDomainName: String {
    get {return _storage._spaceKnowledgeDomainName}
    set {_uniqueStorage()._spaceKnowledgeDomainName = newValue}
  }

  var spaceKnowledgeDomainDescription: String {
    get {return _storage._spaceKnowledgeDomainDescription}
    set {_uniqueStorage()._spaceKnowledgeDomainDescription = newValue}
  }

  var spaceKnowledgeDomainCollarEnum: Elint_Entity_SpaceKnowledgeDomainCollarEnum {
    get {return _storage._spaceKnowledgeDomainCollarEnum}
    set {_uniqueStorage()._spaceKnowledgeDomainCollarEnum = newValue}
  }

  var spaceKnowledge: Elint_Entity_SpaceKnowledge {
    get {return _storage._spaceKnowledge ?? Elint_Entity_SpaceKnowledge()}
    set {_uniqueStorage()._spaceKnowledge = newValue}
  }
  /// Returns true if `spaceKnowledge` has been explicitly set.
  var hasSpaceKnowledge: Bool {return _storage._spaceKnowledge != nil}
  /// Clears the value of `spaceKnowledge`. Subsequent reads from it will return its default value.
  mutating func clearSpaceKnowledge() {_uniqueStorage()._spaceKnowledge = nil}

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var lastUpdatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastUpdatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastUpdatedAt = newValue}
  }
  /// Returns true if `lastUpdatedAt` has been explicitly set.
  var hasLastUpdatedAt: Bool {return _storage._lastUpdatedAt != nil}
  /// Clears the value of `lastUpdatedAt`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdatedAt() {_uniqueStorage()._lastUpdatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Elint_Entity_SpaceKnowledgeDomainAccessMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var knowledgeDomainID: String = String()

  var knowledgeAccessSessionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "elint.entity"

extension Elint_Entity_SpaceKnowledgeDomainCollarEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITE_COLLAR"),
    1: .same(proto: "BLUE_COLLAR"),
    2: .same(proto: "PINK_COLLAR"),
    3: .same(proto: "GOLD_COLLAR"),
    4: .same(proto: "RED_COLLAR"),
    5: .same(proto: "PURPLE_COLLAR"),
    6: .same(proto: "NEW_COLLAR"),
    7: .same(proto: "NO_COLLAR"),
    8: .same(proto: "ORANGE_COLLAR"),
    9: .same(proto: "GREEN_COLLAR"),
    10: .same(proto: "SCARLET_COLLAR"),
    11: .same(proto: "BROWN_COLLAR"),
    12: .same(proto: "STEEL_COLLAR"),
    13: .same(proto: "BLACK_COLLAR"),
    14: .same(proto: "GREY_COLLAR"),
  ]
}

extension Elint_Entity_SpaceKnowledgeDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpaceKnowledgeDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "space_knowledge_domain_id"),
    3: .standard(proto: "space_knowledge_domain_name"),
    4: .standard(proto: "space_knowledge_domain_description"),
    5: .standard(proto: "space_knowledge_domain_collar_enum"),
    6: .standard(proto: "space_knowledge"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "last_updated_at"),
  ]

  fileprivate class _StorageClass {
    var _spaceKnowledgeDomainID: String = String()
    var _spaceKnowledgeDomainName: String = String()
    var _spaceKnowledgeDomainDescription: String = String()
    var _spaceKnowledgeDomainCollarEnum: Elint_Entity_SpaceKnowledgeDomainCollarEnum = .whiteCollar
    var _spaceKnowledge: Elint_Entity_SpaceKnowledge? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastUpdatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _spaceKnowledgeDomainID = source._spaceKnowledgeDomainID
      _spaceKnowledgeDomainName = source._spaceKnowledgeDomainName
      _spaceKnowledgeDomainDescription = source._spaceKnowledgeDomainDescription
      _spaceKnowledgeDomainCollarEnum = source._spaceKnowledgeDomainCollarEnum
      _spaceKnowledge = source._spaceKnowledge
      _createdAt = source._createdAt
      _lastUpdatedAt = source._lastUpdatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._spaceKnowledgeDomainID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._spaceKnowledgeDomainName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._spaceKnowledgeDomainDescription) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._spaceKnowledgeDomainCollarEnum) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._spaceKnowledge) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastUpdatedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._spaceKnowledgeDomainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spaceKnowledgeDomainID, fieldNumber: 1)
      }
      if !_storage._spaceKnowledgeDomainName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spaceKnowledgeDomainName, fieldNumber: 3)
      }
      if !_storage._spaceKnowledgeDomainDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spaceKnowledgeDomainDescription, fieldNumber: 4)
      }
      if _storage._spaceKnowledgeDomainCollarEnum != .whiteCollar {
        try visitor.visitSingularEnumField(value: _storage._spaceKnowledgeDomainCollarEnum, fieldNumber: 5)
      }
      if let v = _storage._spaceKnowledge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._lastUpdatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Elint_Entity_SpaceKnowledgeDomain, rhs: Elint_Entity_SpaceKnowledgeDomain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._spaceKnowledgeDomainID != rhs_storage._spaceKnowledgeDomainID {return false}
        if _storage._spaceKnowledgeDomainName != rhs_storage._spaceKnowledgeDomainName {return false}
        if _storage._spaceKnowledgeDomainDescription != rhs_storage._spaceKnowledgeDomainDescription {return false}
        if _storage._spaceKnowledgeDomainCollarEnum != rhs_storage._spaceKnowledgeDomainCollarEnum {return false}
        if _storage._spaceKnowledge != rhs_storage._spaceKnowledge {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._lastUpdatedAt != rhs_storage._lastUpdatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Elint_Entity_SpaceKnowledgeDomainAccessMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpaceKnowledgeDomainAccessMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "knowledge_domain_id"),
    2: .standard(proto: "knowledge_access_session_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.knowledgeDomainID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.knowledgeAccessSessionToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.knowledgeDomainID.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeDomainID, fieldNumber: 1)
    }
    if !self.knowledgeAccessSessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeAccessSessionToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Elint_Entity_SpaceKnowledgeDomainAccessMeta, rhs: Elint_Entity_SpaceKnowledgeDomainAccessMeta) -> Bool {
    if lhs.knowledgeDomainID != rhs.knowledgeDomainID {return false}
    if lhs.knowledgeAccessSessionToken != rhs.knowledgeAccessSessionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
